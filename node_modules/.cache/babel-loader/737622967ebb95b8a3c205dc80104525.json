{"ast":null,"code":"import { ITSELF as r, createInterpreter as n } from \"@ucast/core\";\nfunction t(r, n, t) {\n  for (var u = 0, e = r.length; u < e; u++) if (0 === t(r[u], n)) return !0;\n  return !1;\n}\nfunction u(r, n) {\n  return Array.isArray(r) && Number.isNaN(Number(n));\n}\nfunction e(r, n, t) {\n  if (!u(r, n)) return t(r, n);\n  for (var e = [], o = 0; o < r.length; o++) {\n    var i = t(r[o], n);\n    void 0 !== i && (e = e.concat(i));\n  }\n  return e;\n}\nfunction o(r) {\n  return function (n, t, u) {\n    var e = u.get(t, n.field);\n    return Array.isArray(e) ? e.some(function (t) {\n      return r(n, t, u);\n    }) : r(n, e, u);\n  };\n}\nfunction i() {\n  return (i = Object.assign || function (r) {\n    for (var n = 1; n < arguments.length; n++) {\n      var t = arguments[n];\n      for (var u in t) Object.prototype.hasOwnProperty.call(t, u) && (r[u] = t[u]);\n    }\n    return r;\n  }).apply(this, arguments);\n}\nvar f = function (r, n) {\n  return r[n];\n};\nfunction c(r, n, t) {\n  var u = n.lastIndexOf(\".\");\n  return -1 === u ? [r, n] : [t(r, n.slice(0, u)), n.slice(u + 1)];\n}\nfunction a(n, t, u) {\n  if (void 0 === u && (u = f), t === r) return n;\n  if (!n) throw new Error('Unable to get field \"' + t + '\" out of ' + String(n) + \".\");\n  return function (r, n, t) {\n    if (-1 === n.indexOf(\".\")) return e(r, n, t);\n    for (var u = n.split(\".\"), o = r, i = 0, f = u.length; i < f; i++) if (!(o = e(o, u[i], t)) || \"object\" != typeof o) return o;\n    return o;\n  }(n, t, u);\n}\nfunction v(r) {\n  return function (n, t) {\n    return a(n, t, r);\n  };\n}\nfunction l(r, n) {\n  return r === n ? 0 : r > n ? 1 : -1;\n}\nfunction y(r, t) {\n  return void 0 === t && (t = {}), n(r, i({\n    get: a,\n    compare: l\n  }, t));\n}\nvar b = function (r, n, t) {\n    var u = t.interpret;\n    return r.value.some(function (r) {\n      return u(r, n);\n    });\n  },\n  m = function (r, n, t) {\n    return !b(r, n, t);\n  },\n  d = function (r, n, t) {\n    var u = t.interpret;\n    return r.value.every(function (r) {\n      return u(r, n);\n    });\n  },\n  g = function (r, n, t) {\n    return !(0, t.interpret)(r.value[0], n);\n  },\n  p = function (r, n, u) {\n    var e = u.compare,\n      o = (0, u.get)(n, r.field);\n    return Array.isArray(o) && !Array.isArray(r.value) ? t(o, r.value, e) : 0 === e(o, r.value);\n  },\n  A = function (r, n, t) {\n    return !p(r, n, t);\n  },\n  s = o(function (r, n, t) {\n    var u = t.compare(n, r.value);\n    return 0 === u || -1 === u;\n  }),\n  h = o(function (r, n, t) {\n    return -1 === t.compare(n, r.value);\n  }),\n  j = o(function (r, n, t) {\n    return 1 === t.compare(n, r.value);\n  }),\n  w = o(function (r, n, t) {\n    var u = t.compare(n, r.value);\n    return 0 === u || 1 === u;\n  }),\n  _ = function (n, t, e) {\n    var o = e.get;\n    if (n.field === r) return void 0 !== t;\n    var i = c(t, n.field, o),\n      f = i[0],\n      a = i[1],\n      v = function (r) {\n        return null == r ? Boolean(r) === n.value : r.hasOwnProperty(a) === n.value;\n      };\n    return u(f, a) ? f.some(v) : v(f);\n  },\n  x = o(function (r, n) {\n    return \"number\" == typeof n && n % r.value[0] === r.value[1];\n  }),\n  O = function (n, t, e) {\n    var o = e.get,\n      i = c(t, n.field, o),\n      f = i[0],\n      a = i[1],\n      v = function (r) {\n        var t = o(r, a);\n        return Array.isArray(t) && t.length === n.value;\n      };\n    return n.field !== r && u(f, a) ? f.some(v) : v(f);\n  },\n  N = o(function (r, n) {\n    return \"string\" == typeof n && r.value.test(n);\n  }),\n  q = o(function (r, n, u) {\n    var e = u.compare;\n    return t(r.value, n, e);\n  }),\n  z = function (r, n, t) {\n    return !q(r, n, t);\n  },\n  B = function (r, n, u) {\n    var e = u.compare,\n      o = (0, u.get)(n, r.field);\n    return Array.isArray(o) && r.value.every(function (r) {\n      return t(o, r, e);\n    });\n  },\n  E = function (r, n, t) {\n    var u = t.interpret,\n      e = (0, t.get)(n, r.field);\n    return Array.isArray(e) && e.some(function (n) {\n      return u(r.value, n);\n    });\n  },\n  M = function (r, n) {\n    return r.value.call(n);\n  },\n  S = i({}, Object.freeze({\n    __proto__: null,\n    or: b,\n    nor: m,\n    and: d,\n    not: g,\n    eq: p,\n    ne: A,\n    lte: s,\n    lt: h,\n    gt: j,\n    gte: w,\n    exists: _,\n    mod: x,\n    size: O,\n    regex: N,\n    within: q,\n    nin: z,\n    all: B,\n    elemMatch: E,\n    where: M\n  }), {\n    in: q\n  }),\n  U = y(S);\nexport { B as all, S as allInterpreters, d as and, l as compare, v as createGetter, y as createJsInterpreter, E as elemMatch, p as eq, _ as exists, a as getObjectField, c as getObjectFieldCursor, j as gt, w as gte, U as interpret, h as lt, s as lte, x as mod, A as ne, z as nin, m as nor, g as not, b as or, N as regex, O as size, M as where, q as within };","map":{"version":3,"names":["t","r","n","u","e","length","Array","isArray","Number","isNaN","o","i","concat","get","field","some","Object","assign","arguments","prototype","hasOwnProperty","call","apply","f","defaultGet","c","lastIndexOf","slice","a","Error","String","indexOf","split","v","l","y","compare","b","or","interpret","value","m","nor","d","and","every","g","not","p","eq","A","ne","s","h","j","w","_","exists","test","Boolean","x","O","size","N","q","z","nin","B","all","E","elemMatch","M","where","S","freeze","__proto__","lte","lt","gt","gte","mod","regex","within","in","U","allInterpreters","createGetter","createJsInterpreter","getObjectField","getObjectFieldCursor"],"sources":["../../src/utils.ts","../../src/interpreter.ts","../../src/interpreters.ts","../../src/defaults.ts"],"sourcesContent":["import { FieldCondition } from '@ucast/core';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nexport type AnyObject = Record<PropertyKey, unknown>;\nexport type GetField = (object: any, field: string) => any;\n\nexport function includes<T>(\n  items: T[],\n  value: T,\n  compare: JsInterpretationOptions['compare']\n): boolean {\n  for (let i = 0, length = items.length; i < length; i++) {\n    if (compare(items[i], value) === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function isArrayAndNotNumericField<T>(object: T | T[], field: string): object is T[] {\n  return Array.isArray(object) && Number.isNaN(Number(field));\n}\n\nfunction getField<T extends AnyObject>(object: T | T[], field: string, get: GetField) {\n  if (!isArrayAndNotNumericField(object, field)) {\n    return get(object, field);\n  }\n\n  let result: unknown[] = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const value = get(object[i], field);\n    if (typeof value !== 'undefined') {\n      result = result.concat(value);\n    }\n  }\n\n  return result;\n}\n\nexport function getValueByPath(object: AnyObject, field: string, get: GetField) {\n  if (field.indexOf('.') === -1) {\n    return getField(object, field, get);\n  }\n\n  const paths = field.split('.');\n  let value = object;\n\n  for (let i = 0, length = paths.length; i < length; i++) {\n    value = getField(value, paths[i], get);\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n  }\n\n  return value;\n}\n\nexport function testValueOrArray<T, U = T>(test: JsInterpreter<FieldCondition<T>, U>) {\n  return ((node, object, context) => {\n    const value = context.get(object, node.field);\n\n    if (!Array.isArray(value)) {\n      return test(node, value, context);\n    }\n\n    return value.some(v => test(node, v, context));\n  }) as JsInterpreter<FieldCondition<T>, AnyObject | U>;\n}\n","import { createInterpreter, ITSELF } from '@ucast/core';\nimport { getValueByPath, AnyObject, GetField } from './utils';\nimport { JsInterpretationOptions, JsInterpreter } from './types';\n\nconst defaultGet = (object: AnyObject, field: string) => object[field];\ntype Field = string | typeof ITSELF;\n\nexport function getObjectFieldCursor<T extends {}>(object: T, path: string, get: GetField) {\n  const dotIndex = path.lastIndexOf('.');\n\n  if (dotIndex === -1) {\n    return [object, path] as const;\n  }\n\n  return [\n    get(object, path.slice(0, dotIndex)) as T,\n    path.slice(dotIndex + 1)\n  ] as const;\n}\n\nexport function getObjectField(object: unknown, field: Field, get: GetField = defaultGet) {\n  if (field === ITSELF) {\n    return object;\n  }\n\n  if (!object) {\n    throw new Error(`Unable to get field \"${field}\" out of ${String(object)}.`);\n  }\n\n  return getValueByPath(object as Record<string, unknown>, field, get);\n}\n\nexport function createGetter<T extends GetField>(get: T) {\n  return (object: Parameters<T>[0], field: Parameters<T>[1]) => getObjectField(object, field, get);\n}\n\nexport function compare<T>(a: T, b: T): 0 | 1 | -1 {\n  if (a === b) {\n    return 0;\n  }\n\n  return a > b ? 1 : -1;\n}\n\nexport function createJsInterpreter<\n  T extends JsInterpreter<any>,\n  O extends Partial<JsInterpretationOptions>\n>(\n  operators: Record<string, T>,\n  options: O = {} as O\n) {\n  return createInterpreter(operators, {\n    get: getObjectField,\n    compare,\n    ...options,\n  });\n}\n","import {\n  CompoundCondition as Compound,\n  FieldCondition as Field,\n  DocumentCondition as Document,\n  Condition,\n  Comparable,\n  ITSELF,\n} from '@ucast/core';\nimport { JsInterpreter as Interpret } from './types';\nimport {\n  includes,\n  testValueOrArray,\n  isArrayAndNotNumericField,\n  AnyObject,\n} from './utils';\nimport { getObjectFieldCursor } from './interpreter';\n\nexport const or: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.some(condition => interpret(condition, object));\n};\n\nexport const nor: typeof or = (node, object, context) => {\n  return !or(node, object, context);\n};\n\nexport const and: Interpret<Compound> = (node, object, { interpret }) => {\n  return node.value.every(condition => interpret(condition, object));\n};\n\nexport const not: Interpret<Compound> = (node, object, { interpret }) => {\n  return !interpret(node.value[0], object);\n};\n\nexport const eq: Interpret<Field> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n\n  if (Array.isArray(value) && !Array.isArray(node.value)) {\n    return includes(value, node.value, compare);\n  }\n\n  return compare(value, node.value) === 0;\n};\n\nexport const ne: typeof eq = (node, object, context) => {\n  return !eq(node, object, context);\n};\n\nexport const lte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === -1;\n});\n\nexport const lt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === -1;\n});\nexport const gt = testValueOrArray<Comparable>((node, value, context) => {\n  return context.compare(value, node.value) === 1;\n});\nexport const gte = testValueOrArray<Comparable>((node, value, context) => {\n  const result = context.compare(value, node.value);\n  return result === 0 || result === 1;\n});\n\nexport const exists: Interpret<Field<boolean>> = (node, object, { get }) => {\n  if (node.field === ITSELF) {\n    return typeof object !== 'undefined';\n  }\n\n  const [item, field] = getObjectFieldCursor<{}>(object, node.field, get);\n  const test = (value: {}) => {\n    if (value == null) return Boolean(value) === node.value;\n    return value.hasOwnProperty(field) === node.value;\n  };\n\n  return isArrayAndNotNumericField(item, field) ? item.some(test) : test(item);\n};\n\nexport const mod = testValueOrArray<[number, number], number>((node, value) => {\n  return typeof value === 'number' && value % node.value[0] === node.value[1];\n});\n\nexport const size: Interpret<Field<number>, AnyObject | unknown[]> = (node, object, { get }) => {\n  const [items, field] = getObjectFieldCursor(object as AnyObject, node.field, get);\n  const test = (item: unknown) => {\n    const value = get(item, field);\n    return Array.isArray(value) && value.length === node.value;\n  };\n\n  return node.field !== ITSELF && isArrayAndNotNumericField(items, field)\n    ? items.some(test)\n    : test(items);\n};\n\nexport const regex = testValueOrArray<RegExp, string>((node, value) => {\n  return typeof value === 'string' && node.value.test(value);\n});\n\nexport const within = testValueOrArray<unknown[], unknown>((node, object, { compare }) => {\n  return includes(node.value, object, compare);\n});\n\nexport const nin: typeof within = (node, object, context) => !within(node, object, context);\n\nexport const all: Interpret<Field<unknown[]>> = (node, object, { compare, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && node.value.every(v => includes(value, v, compare));\n};\n\nexport const elemMatch: Interpret<Field<Condition>> = (node, object, { interpret, get }) => {\n  const value = get(object, node.field);\n  return Array.isArray(value) && value.some(v => interpret(node.value, v));\n};\n\ntype WhereFunction = (this: AnyObject) => boolean;\nexport const where: Interpret<Document<WhereFunction>, AnyObject> = (node, object) => {\n  return node.value.call(object);\n};\n","import { createJsInterpreter } from './interpreter';\nimport * as interpreters from './interpreters';\n\nexport const allInterpreters = {\n  ...interpreters,\n  in: interpreters.within,\n};\nexport const interpret = createJsInterpreter(allInterpreters);\n"],"mappings":";AAMO,SAASA,EACdC,CAAA,EACAC,CAAA,EACAF,CAAA;EAAA,KAEK,IAAIG,CAAA,GAAI,GAAGC,CAAA,GAASH,CAAA,CAAMI,MAAA,EAAQF,CAAA,GAAIC,CAAA,EAAQD,CAAA,QAChB,MAA7BH,CAAA,CAAQC,CAAA,CAAME,CAAA,GAAID,CAAA,WACb;EAAA,QAIJ;AAAA;AAGF,SAASC,EAA6BF,CAAA,EAAiBC,CAAA;EAAA,OACrDI,KAAA,CAAMC,OAAA,CAAQN,CAAA,KAAWO,MAAA,CAAOC,KAAA,CAAMD,MAAA,CAAON,CAAA;AAAA;AAGtD,SAASE,EAA8BH,CAAA,EAAiBC,CAAA,EAAeF,CAAA;EAAA,KAChEG,CAAA,CAA0BF,CAAA,EAAQC,CAAA,UAC9BF,CAAA,CAAIC,CAAA,EAAQC,CAAA;EAAA,SAGjBE,CAAA,GAAoB,IAEfM,CAAA,GAAI,GAAGA,CAAA,GAAIT,CAAA,CAAOI,MAAA,EAAQK,CAAA,IAAK;IAAA,IAChCC,CAAA,GAAQX,CAAA,CAAIC,CAAA,CAAOS,CAAA,GAAIR,CAAA;IAAA,KACR,MAAVS,CAAA,KACTP,CAAA,GAASA,CAAA,CAAOQ,MAAA,CAAOD,CAAA;EAAA;EAAA,OAIpBP,CAAA;AAAA;AAsBF,SAASM,EAA2BT,CAAA;EAAA,OACjC,UAACC,CAAA,EAAMF,CAAA,EAAQG,CAAA;IAAA,IACfC,CAAA,GAAQD,CAAA,CAAQU,GAAA,CAAIb,CAAA,EAAQE,CAAA,CAAKY,KAAA;IAAA,OAElCR,KAAA,CAAMC,OAAA,CAAQH,CAAA,IAIZA,CAAA,CAAMW,IAAA,CAAK,UAAAf,CAAA;MAAA,OAAKC,CAAA,CAAKC,CAAA,EAAMF,CAAA,EAAGG,CAAA;IAAA,KAH5BF,CAAA,CAAKC,CAAA,EAAME,CAAA,EAAOD,CAAA;EAAA;AAAA;AAAA,SAAAQ,EAAA;EAAA,QAAAA,CAAA,GAAAK,MAAA,CAAAC,MAAA,cAAAhB,CAAA;IAAA,SAAAC,CAAA,MAAAA,CAAA,GAAAgB,SAAA,CAAAb,MAAA,EAAAH,CAAA;MAAA,IAAAF,CAAA,GAAAkB,SAAA,CAAAhB,CAAA;MAAA,SAAAC,CAAA,IAAAH,CAAA,EAAAgB,MAAA,CAAAG,SAAA,CAAAC,cAAA,CAAAC,IAAA,CAAArB,CAAA,EAAAG,CAAA,MAAAF,CAAA,CAAAE,CAAA,IAAAH,CAAA,CAAAG,CAAA;IAAA;IAAA,OAAAF,CAAA;EAAA,GAAAqB,KAAA,OAAAJ,SAAA;AAAA;AC7D/B,IAAMK,CAAA,GAAa,SAAAC,CAACvB,CAAA,EAAmBC,CAAA;EAAA,OAAkBD,CAAA,CAAOC,CAAA;AAAA;AAGzD,SAASuB,EAAmCxB,CAAA,EAAWC,CAAA,EAAcF,CAAA;EAAA,IACpEG,CAAA,GAAWD,CAAA,CAAKwB,WAAA,CAAY;EAAA,QAEhB,MAAdvB,CAAA,GACK,CAACF,CAAA,EAAQC,CAAA,IAGX,CACLF,CAAA,CAAIC,CAAA,EAAQC,CAAA,CAAKyB,KAAA,CAAM,GAAGxB,CAAA,IAC1BD,CAAA,CAAKyB,KAAA,CAAMxB,CAAA,GAAW;AAAA;AAInB,SAASyB,EAAe1B,CAAA,EAAiBF,CAAA,EAAcG,CAAA;EAAA,eAAAA,CAAA,KAAAA,CAAA,GAAgBoB,CAAA,GACxEvB,CAAA,KAAUC,CAAA,SACLC,CAAA;EAAA,KAGJA,CAAA,QACG,IAAI2B,KAAA,2BAA8B7B,CAAA,iBAAiB8B,MAAA,CAAO5B,CAAA;EAAA,ODe7D,UAAwBD,CAAA,EAAmBC,CAAA,EAAeF,CAAA;IAAA,KACnC,MAAxBE,CAAA,CAAM6B,OAAA,CAAQ,aACT3B,CAAA,CAASH,CAAA,EAAQC,CAAA,EAAOF,CAAA;IAAA,SAG3BG,CAAA,GAAQD,CAAA,CAAM8B,KAAA,CAAM,MACtBtB,CAAA,GAAQT,CAAA,EAEHU,CAAA,GAAI,GAAGY,CAAA,GAASpB,CAAA,CAAME,MAAA,EAAQM,CAAA,GAAIY,CAAA,EAAQZ,CAAA,UACjDD,CAAA,GAAQN,CAAA,CAASM,CAAA,EAAOP,CAAA,CAAMQ,CAAA,GAAIX,CAAA,MAEH,mBAAVU,CAAA,SACZA,CAAA;IAAA,OAIJA,CAAA;EAAA,CC5BA,CAAeR,CAAA,EAAmCF,CAAA,EAAOG,CAAA;AAAA;AAG3D,SAAS8B,EAAiChC,CAAA;EAAA,OACxC,UAACC,CAAA,EAA0BF,CAAA;IAAA,OAA4B4B,CAAA,CAAe1B,CAAA,EAAQF,CAAA,EAAOC,CAAA;EAAA;AAAA;AAGvF,SAASiC,EAAWjC,CAAA,EAAMC,CAAA;EAAA,OAC3BD,CAAA,KAAMC,CAAA,GACD,IAGFD,CAAA,GAAIC,CAAA,GAAI,KAAK;AAAA;AAGf,SAASiC,EAIdlC,CAAA,EACAD,CAAA;EAAA,kBAAAA,CAAA,KAAAA,CAAA,GAAa,KAENE,CAAA,CAAkBD,CAAA,EAAAU,CAAA;IACvBE,GAAA,EAAKe,CAAA;IACLQ,OAAA,EAAAF;EAAA,GACGlC,CAAA;AAAA;AAAA,ICrCMqC,CAAA,GAA0B,SAAAC,CAACrC,CAAA,EAAMC,CAAA,EAAAF,CAAA;IAAA,IAAUG,CAAA,GAAAH,CAAA,CAAAuC,SAAA;IAAA,OAC/CtC,CAAA,CAAKuC,KAAA,CAAMzB,IAAA,CAAK,UAAAd,CAAA;MAAA,OAAaE,CAAA,CAAUF,CAAA,EAAWC,CAAA;IAAA;EAAA;EAG9CuC,CAAA,GAAiB,SAAAC,CAACzC,CAAA,EAAMC,CAAA,EAAQF,CAAA;IAAA,QACnCqC,CAAA,CAAGpC,CAAA,EAAMC,CAAA,EAAQF,CAAA;EAAA;EAGd2C,CAAA,GAA2B,SAAAC,CAAC3C,CAAA,EAAMC,CAAA,EAAAF,CAAA;IAAA,IAAUG,CAAA,GAAAH,CAAA,CAAAuC,SAAA;IAAA,OAChDtC,CAAA,CAAKuC,KAAA,CAAMK,KAAA,CAAM,UAAA5C,CAAA;MAAA,OAAaE,CAAA,CAAUF,CAAA,EAAWC,CAAA;IAAA;EAAA;EAG/C4C,CAAA,GAA2B,SAAAC,CAAC9C,CAAA,EAAMC,CAAA,EAAAF,CAAA;IAAA,SACrC,GAAAA,CAAA,CAD+CuC,SAAA,EACrCtC,CAAA,CAAKuC,KAAA,CAAM,IAAItC,CAAA;EAAA;EAGtB8C,CAAA,GAAuB,SAAAC,CAAChD,CAAA,EAAMC,CAAA,EAAAC,CAAA;IAAA,IAAUC,CAAA,GAAAD,CAAA,CAAAiC,OAAA;MAC7C1B,CAAA,IAAQ,GAAAP,CAAA,CAD8CU,GAAA,EAC1CX,CAAA,EAAQD,CAAA,CAAKa,KAAA;IAAA,OAE3BR,KAAA,CAAMC,OAAA,CAAQG,CAAA,MAAWJ,KAAA,CAAMC,OAAA,CAAQN,CAAA,CAAKuC,KAAA,IACvCxC,CAAA,CAASU,CAAA,EAAOT,CAAA,CAAKuC,KAAA,EAAOpC,CAAA,IAGC,MAA/BA,CAAA,CAAQM,CAAA,EAAOT,CAAA,CAAKuC,KAAA;EAAA;EAGhBU,CAAA,GAAgB,SAAAC,CAAClD,CAAA,EAAMC,CAAA,EAAQF,CAAA;IAAA,QAClCgD,CAAA,CAAG/C,CAAA,EAAMC,CAAA,EAAQF,CAAA;EAAA;EAGdoD,CAAA,GAAM1C,CAAA,CAA6B,UAACT,CAAA,EAAMC,CAAA,EAAOF,CAAA;IAAA,IACtDG,CAAA,GAASH,CAAA,CAAQoC,OAAA,CAAQlC,CAAA,EAAOD,CAAA,CAAKuC,KAAA;IAAA,OACzB,MAAXrC,CAAA,KAA4B,MAAZA,CAAA;EAAA;EAGZkD,CAAA,GAAK3C,CAAA,CAA6B,UAACT,CAAA,EAAMC,CAAA,EAAOF,CAAA;IAAA,QACZ,MAAxCA,CAAA,CAAQoC,OAAA,CAAQlC,CAAA,EAAOD,CAAA,CAAKuC,KAAA;EAAA;EAExBc,CAAA,GAAK5C,CAAA,CAA6B,UAACT,CAAA,EAAMC,CAAA,EAAOF,CAAA;IAAA,OACb,MAAvCA,CAAA,CAAQoC,OAAA,CAAQlC,CAAA,EAAOD,CAAA,CAAKuC,KAAA;EAAA;EAExBe,CAAA,GAAM7C,CAAA,CAA6B,UAACT,CAAA,EAAMC,CAAA,EAAOF,CAAA;IAAA,IACtDG,CAAA,GAASH,CAAA,CAAQoC,OAAA,CAAQlC,CAAA,EAAOD,CAAA,CAAKuC,KAAA;IAAA,OACzB,MAAXrC,CAAA,IAA2B,MAAXA,CAAA;EAAA;EAGZqD,CAAA,GAAoC,SAAAC,CAACvD,CAAA,EAAMF,CAAA,EAAAI,CAAA;IAAA,IAAUM,CAAA,GAAAN,CAAA,CAAAS,GAAA;IAAA,IAC5DX,CAAA,CAAKY,KAAA,KAAUb,CAAA,cACQ,MAAXD,CAAA;IAAA,IAAAW,CAAA,GAGMc,CAAA,CAAyBzB,CAAA,EAAQE,CAAA,CAAKY,KAAA,EAAOJ,CAAA;MAA5Da,CAAA,GAAAZ,CAAA;MAAMiB,CAAA,GAAAjB,CAAA;MACPsB,CAAA,GAAO,SAAAyB,CAACzD,CAAA;QAAA,OACC,QAATA,CAAA,GAAsB0D,OAAA,CAAQ1D,CAAA,MAAWC,CAAA,CAAKsC,KAAA,GAC3CvC,CAAA,CAAMmB,cAAA,CAAeQ,CAAA,MAAW1B,CAAA,CAAKsC,KAAA;MAAA;IAAA,OAGvCrC,CAAA,CAA0BoB,CAAA,EAAMK,CAAA,IAASL,CAAA,CAAKR,IAAA,CAAKkB,CAAA,IAAQA,CAAA,CAAKV,CAAA;EAAA;EAG5DqC,CAAA,GAAMlD,CAAA,CAA2C,UAACT,CAAA,EAAMC,CAAA;IAAA,OAC3C,mBAAVA,CAAA,IAAsBA,CAAA,GAAQD,CAAA,CAAKuC,KAAA,CAAM,OAAOvC,CAAA,CAAKuC,KAAA,CAAM;EAAA;EAG9DqB,CAAA,GAAwD,SAAAC,CAAC5D,CAAA,EAAMF,CAAA,EAAAI,CAAA;IAAA,IAAUM,CAAA,GAAAN,CAAA,CAAAS,GAAA;MAAAF,CAAA,GAC7Dc,CAAA,CAAqBzB,CAAA,EAAqBE,CAAA,CAAKY,KAAA,EAAOJ,CAAA;MAAtEa,CAAA,GAAAZ,CAAA;MAAOiB,CAAA,GAAAjB,CAAA;MACRsB,CAAA,GAAO,SAAAyB,CAACzD,CAAA;QAAA,IACND,CAAA,GAAQU,CAAA,CAAIT,CAAA,EAAM2B,CAAA;QAAA,OACjBtB,KAAA,CAAMC,OAAA,CAAQP,CAAA,KAAUA,CAAA,CAAMK,MAAA,KAAWH,CAAA,CAAKsC,KAAA;MAAA;IAAA,OAGhDtC,CAAA,CAAKY,KAAA,KAAUb,CAAA,IAAUE,CAAA,CAA0BoB,CAAA,EAAOK,CAAA,IAC7DL,CAAA,CAAMR,IAAA,CAAKkB,CAAA,IACXA,CAAA,CAAKV,CAAA;EAAA;EAGEwC,CAAA,GAAQrD,CAAA,CAAiC,UAACT,CAAA,EAAMC,CAAA;IAAA,OACnC,mBAAVA,CAAA,IAAsBD,CAAA,CAAKuC,KAAA,CAAMkB,IAAA,CAAKxD,CAAA;EAAA;EAGzC8D,CAAA,GAAStD,CAAA,CAAqC,UAACT,CAAA,EAAMC,CAAA,EAAAC,CAAA;IAAA,IAAUC,CAAA,GAAAD,CAAA,CAAAiC,OAAA;IAAA,OACnEpC,CAAA,CAASC,CAAA,CAAKuC,KAAA,EAAOtC,CAAA,EAAQE,CAAA;EAAA;EAGzB6D,CAAA,GAAqB,SAAAC,CAACjE,CAAA,EAAMC,CAAA,EAAQF,CAAA;IAAA,QAAagE,CAAA,CAAO/D,CAAA,EAAMC,CAAA,EAAQF,CAAA;EAAA;EAEtEmE,CAAA,GAAmC,SAAAC,CAACnE,CAAA,EAAMC,CAAA,EAAAC,CAAA;IAAA,IAAUC,CAAA,GAAAD,CAAA,CAAAiC,OAAA;MACzD1B,CAAA,IAAQ,GAAAP,CAAA,CAD0DU,GAAA,EACtDX,CAAA,EAAQD,CAAA,CAAKa,KAAA;IAAA,OACxBR,KAAA,CAAMC,OAAA,CAAQG,CAAA,KAAUT,CAAA,CAAKuC,KAAA,CAAMK,KAAA,CAAM,UAAA5C,CAAA;MAAA,OAAKD,CAAA,CAASU,CAAA,EAAOT,CAAA,EAAGG,CAAA;IAAA;EAAA;EAG7DiE,CAAA,GAAyC,SAAAC,CAACrE,CAAA,EAAMC,CAAA,EAAAF,CAAA;IAAA,IAAUG,CAAA,GAAAH,CAAA,CAAAuC,SAAA;MAC/DnC,CAAA,IAAQ,GAAAJ,CAAA,CADkEa,GAAA,EAC9DX,CAAA,EAAQD,CAAA,CAAKa,KAAA;IAAA,OACxBR,KAAA,CAAMC,OAAA,CAAQH,CAAA,KAAUA,CAAA,CAAMW,IAAA,CAAK,UAAAb,CAAA;MAAA,OAAKC,CAAA,CAAUF,CAAA,CAAKuC,KAAA,EAAOtC,CAAA;IAAA;EAAA;EAI1DqE,CAAA,GAAuD,SAAAC,CAACvE,CAAA,EAAMC,CAAA;IAAA,OAClED,CAAA,CAAKuC,KAAA,CAAMnB,IAAA,CAAKnB,CAAA;EAAA;EChHZuE,CAAA,GAAA9D,CAAA,KAAAK,MAAA,CAAA0D,MAAA;IAAAC,SAAA;IAAArC,EAAA,EAAAD,CAAA;IAAAK,GAAA,EAAAD,CAAA;IAAAG,GAAA,EAAAD,CAAA;IAAAI,GAAA,EAAAD,CAAA;IAAAG,EAAA,EAAAD,CAAA;IAAAG,EAAA,EAAAD,CAAA;IAAA0B,GAAA,EAAAxB,CAAA;IAAAyB,EAAA,EAAAxB,CAAA;IAAAyB,EAAA,EAAAxB,CAAA;IAAAyB,GAAA,EAAAxB,CAAA;IAAAE,MAAA,EAAAD,CAAA;IAAAwB,GAAA,EAAApB,CAAA;IAAAE,IAAA,EAAAD,CAAA;IAAAoB,KAAA,EAAAlB,CAAA;IAAAmB,MAAA,EAAAlB,CAAA;IAAAE,GAAA,EAAAD,CAAA;IAAAG,GAAA,EAAAD,CAAA;IAAAG,SAAA,EAAAD,CAAA;IAAAG,KAAA,EAAAD;EAAA;IAEXY,EAAA,EAAInB;EAAA;EAEOoB,CAAA,GAAYjD,CAAA,CAAoBsC,CAAA;AAAA,SAAAN,CAAA,IAAAC,GAAA,EAAAK,CAAA,IAAAY,eAAA,EAAA1C,CAAA,IAAAC,GAAA,EAAAV,CAAA,IAAAE,OAAA,EAAAH,CAAA,IAAAqD,YAAA,EAAAnD,CAAA,IAAAoD,mBAAA,EAAAlB,CAAA,IAAAC,SAAA,EAAAtB,CAAA,IAAAC,EAAA,EAAAO,CAAA,IAAAC,MAAA,EAAA7B,CAAA,IAAA4D,cAAA,EAAA/D,CAAA,IAAAgE,oBAAA,EAAAnC,CAAA,IAAAwB,EAAA,EAAAvB,CAAA,IAAAwB,GAAA,EAAAK,CAAA,IAAA7C,SAAA,EAAAc,CAAA,IAAAwB,EAAA,EAAAzB,CAAA,IAAAwB,GAAA,EAAAhB,CAAA,IAAAoB,GAAA,EAAA9B,CAAA,IAAAC,EAAA,EAAAc,CAAA,IAAAC,GAAA,EAAAzB,CAAA,IAAAC,GAAA,EAAAI,CAAA,IAAAC,GAAA,EAAAV,CAAA,IAAAC,EAAA,EAAAyB,CAAA,IAAAkB,KAAA,EAAApB,CAAA,IAAAC,IAAA,EAAAS,CAAA,IAAAC,KAAA,EAAAR,CAAA,IAAAkB,MAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}