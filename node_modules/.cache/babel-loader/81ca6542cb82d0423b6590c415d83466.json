{"ast":null,"code":"function t(t, r) {\n  for (var n = 0; n < r.length; n++) {\n    var i = r[n];\n    i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n  }\n}\nfunction r() {\n  return (r = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var n = arguments[r];\n      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);\n    }\n    return t;\n  }).apply(this, arguments);\n}\nfunction n(t, r) {\n  t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;\n}\nvar i = function () {\n    function r(t, r) {\n      this.operator = t, this.value = r, Object.defineProperty(this, \"t\", {\n        writable: !0\n      });\n    }\n    var n, i, e;\n    return r.prototype.addNote = function (t) {\n      this.t = this.t || [], this.t.push(t);\n    }, n = r, (i = [{\n      key: \"notes\",\n      get: function () {\n        return this.t;\n      }\n    }]) && t(n.prototype, i), e && t(n, e), r;\n  }(),\n  e = function (t) {\n    function r() {\n      return t.apply(this, arguments) || this;\n    }\n    return n(r, t), r;\n  }(i),\n  o = function (t) {\n    function r(r, n) {\n      if (!Array.isArray(n)) throw new Error('\"' + r + '\" operator expects to receive an array of conditions');\n      return t.call(this, r, n) || this;\n    }\n    return n(r, t), r;\n  }(e),\n  u = \"__itself__\",\n  f = function (t) {\n    function r(r, n, i) {\n      var e;\n      return (e = t.call(this, r, i) || this).field = n, e;\n    }\n    return n(r, t), r;\n  }(i),\n  a = new e(\"__null__\", null),\n  c = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\nfunction s(t, r) {\n  return r instanceof o && r.operator === t;\n}\nfunction h(t, r) {\n  return 1 === r.length ? r[0] : new o(t, function t(r, n, i) {\n    for (var e = i || [], o = 0, u = n.length; o < u; o++) {\n      var f = n[o];\n      s(r, f) ? t(r, f.value, e) : e.push(f);\n    }\n    return e;\n  }(t, r));\n}\nvar v = function (t) {\n    return t;\n  },\n  d = function () {\n    return Object.create(null);\n  },\n  l = Object.defineProperty(d(), \"__@type@__\", {\n    value: \"ignore value\"\n  });\nfunction p(t, r, n) {\n  if (void 0 === n && (n = !1), !t || t && t.constructor !== Object) return !1;\n  for (var i in t) {\n    if (c(t, i) && c(r, i) && (!n || t[i] !== l)) return !0;\n  }\n  return !1;\n}\nfunction w(t) {\n  var r = [];\n  for (var n in t) c(t, n) && t[n] !== l && r.push(n);\n  return r;\n}\nfunction b(t, r) {\n  r !== a && t.push(r);\n}\nvar y = function (t) {\n    return h(\"and\", t);\n  },\n  O = function (t) {\n    return h(\"or\", t);\n  },\n  j = {\n    compound: function (t, r, n) {\n      var i = (Array.isArray(r) ? r : [r]).map(function (t) {\n        return n.parse(t);\n      });\n      return new o(t.name, i);\n    },\n    field: function (t, r, n) {\n      return new f(t.name, n.field, r);\n    },\n    document: function (t, r) {\n      return new e(t.name, r);\n    }\n  },\n  _ = function () {\n    function t(t, n) {\n      var i = this;\n      void 0 === n && (n = d()), this.i = void 0, this.o = void 0, this.u = void 0, this.s = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.s = {\n        operatorToConditionName: n.operatorToConditionName || v,\n        defaultOperatorName: n.defaultOperatorName || \"eq\",\n        mergeFinalConditions: n.mergeFinalConditions || y\n      }, this.i = Object.keys(t).reduce(function (n, e) {\n        return n[e] = r({\n          name: i.s.operatorToConditionName(e)\n        }, t[e]), n;\n      }, {}), this.o = r({}, n.fieldContext, {\n        field: \"\",\n        query: {},\n        parse: this.parse,\n        hasOperators: function (t) {\n          return p(t, i.i, n.useIgnoreValue);\n        }\n      }), this.u = r({}, n.documentContext, {\n        parse: this.parse,\n        query: {}\n      }), this.h = n.useIgnoreValue ? w : Object.keys;\n    }\n    var n = t.prototype;\n    return n.setParse = function (t) {\n      this.parse = t, this.o.parse = t, this.u.parse = t;\n    }, n.parseField = function (t, r, n, i) {\n      var e = this.i[r];\n      if (!e) throw new Error('Unsupported operator \"' + r + '\"');\n      if (\"field\" !== e.type) throw new Error(\"Unexpected \" + e.type + ' operator \"' + r + '\" at field level');\n      return this.o.field = t, this.o.query = i, this.parseInstruction(e, n, this.o);\n    }, n.parseInstruction = function (t, r, n) {\n      return \"function\" == typeof t.validate && t.validate(t, r), (t.parse || j[t.type])(t, r, n);\n    }, n.parseFieldOperators = function (t, r) {\n      for (var n = [], i = this.h(r), e = 0, o = i.length; e < o; e++) {\n        var u = i[e];\n        if (!this.i[u]) throw new Error('Field query for \"' + t + '\" may contain only operators or a plain object as a value');\n        b(n, this.parseField(t, u, r[u], r));\n      }\n      return n;\n    }, n.parse = function (t) {\n      var r = [],\n        n = this.h(t);\n      this.u.query = t;\n      for (var i = 0, e = n.length; i < e; i++) {\n        var o = n[i],\n          u = t[o],\n          f = this.i[o];\n        if (f) {\n          if (\"document\" !== f.type && \"compound\" !== f.type) throw new Error('Cannot use parsing instruction for operator \"' + o + '\" in \"document\" context as it is supposed to be used in  \"' + f.type + '\" context');\n          b(r, this.parseInstruction(f, u, this.u));\n        } else this.o.hasOperators(u) ? r.push.apply(r, this.parseFieldOperators(o, u)) : b(r, this.parseField(o, this.s.defaultOperatorName, u, t));\n      }\n      return this.s.mergeFinalConditions(r);\n    }, t;\n  }();\nfunction m(t, r) {\n  var n = t[r];\n  if (\"function\" != typeof n) throw new Error('Unable to interpret \"' + r + '\" condition. Did you forget to register interpreter for it?');\n  return n;\n}\nfunction g(t) {\n  return t.operator;\n}\nfunction E(t, n) {\n  var i,\n    e = n,\n    o = e && e.getInterpreterName || g;\n  switch (e ? e.numberOfArguments : 0) {\n    case 1:\n      i = function (r) {\n        var n = o(r, e);\n        return m(t, n)(r, u);\n      };\n      break;\n    case 3:\n      i = function (r, n, i) {\n        var f = o(r, e);\n        return m(t, f)(r, n, i, u);\n      };\n      break;\n    default:\n      i = function (r, n) {\n        var i = o(r, e);\n        return m(t, i)(r, n, u);\n      };\n  }\n  var u = r({}, e, {\n    interpret: i\n  });\n  return u.interpret;\n}\nfunction x(t, r) {\n  return function (n) {\n    for (var i = arguments.length, e = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) e[o - 1] = arguments[o];\n    var u = t.apply(void 0, [n].concat(e)),\n      f = r.bind(null, u);\n    return f.ast = u, f;\n  };\n}\nvar q = _.prototype.parseInstruction;\nexport { o as CompoundCondition, i as Condition, e as DocumentCondition, f as FieldCondition, u as ITSELF, a as NULL_CONDITION, _ as ObjectQueryParser, y as buildAnd, O as buildOr, E as createInterpreter, x as createTranslatorFactory, j as defaultInstructionParsers, p as hasOperators, v as identity, l as ignoreValue, s as isCompound, d as object, h as optimizedCompoundCondition, q as parseInstruction };","map":{"version":3,"names":["i","r","t","operator","value","Object","defineProperty","writable","n","e","prototype","addNote","push","key","get","apply","arguments","o","Array","isArray","Error","call","u","f","field","a","c","hasOwnProperty","bind","s","h","length","v","identity","d","object","create","l","p","constructor","w","b","y","buildAnd","O","buildOr","j","compound","map","parse","name","document","_","operatorToConditionName","defaultOperatorName","mergeFinalConditions","keys","reduce","fieldContext","query","hasOperators","useIgnoreValue","documentContext","setParse","parseField","type","parseInstruction","validate","parseFieldOperators","m","g","E","getInterpreterName","numberOfArguments","interpret","x","concat","ast","q","CompoundCondition","Condition","DocumentCondition","FieldCondition","ITSELF","NULL_CONDITION","ObjectQueryParser","createInterpreter","createTranslatorFactory","defaultInstructionParsers","ignoreValue","isCompound","optimizedCompoundCondition"],"sources":["../../src/Condition.ts","../../src/utils.ts","../../src/builder.ts","../../src/parsers/defaultInstructionParsers.ts","../../src/parsers/ObjectQueryParser.ts","../../src/interpreter.ts","../../src/translator.ts","../../src/index.ts"],"sourcesContent":["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}