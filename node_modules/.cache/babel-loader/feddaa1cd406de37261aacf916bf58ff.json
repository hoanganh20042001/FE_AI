{"ast":null,"code":"import { createFactory as t, $eq as r, $ne as i, $lt as n, $lte as e, $gt as u, $gte as o, $in as f, $nin as s, $all as a, $size as c, $regex as h, $options as v, $elemMatch as l, $exists as d, eq as b, ne as y, lt as p, lte as w, gt as g, gte as A, within as j, nin as m, all as E, size as M, regex as $, elemMatch as O, exists as x, and as F } from \"@ucast/mongo2js\";\nfunction _(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var i = t[Symbol.toPrimitive];\n  if (void 0 !== i) {\n    var n = i.call(t, r || \"default\");\n    if (\"object\" != typeof n) return n;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction S(t) {\n  var r = _(t, \"string\");\n  return \"symbol\" == typeof r ? r : String(r);\n}\nfunction C(t, r) {\n  for (var i = 0; i < r.length; i++) {\n    var n = r[i];\n    n.enumerable = n.enumerable || false;\n    n.configurable = true;\n    if (\"value\" in n) n.writable = true;\n    Object.defineProperty(t, S(n.key), n);\n  }\n}\nfunction P(t, r, i) {\n  if (r) C(t.prototype, r);\n  if (i) C(t, i);\n  Object.defineProperty(t, \"prototype\", {\n    writable: false\n  });\n  return t;\n}\nfunction R() {\n  R = Object.assign ? Object.assign.bind() : function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var i = arguments[r];\n      for (var n in i) if (Object.prototype.hasOwnProperty.call(i, n)) t[n] = i[n];\n    }\n    return t;\n  };\n  return R.apply(this, arguments);\n}\nfunction T(t, r) {\n  t.prototype = Object.create(r.prototype);\n  t.prototype.constructor = t;\n  k(t, r);\n}\nfunction k(t, r) {\n  k = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function t(r, i) {\n    r.__proto__ = i;\n    return r;\n  };\n  return k(t, r);\n}\nfunction B(t) {\n  if (t === void 0) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\nfunction q(t) {\n  return Array.isArray(t) ? t : [t];\n}\nvar z = \"__caslSubjectType__\";\nfunction Y(t, r) {\n  if (r) if (!Object.hasOwn(r, z)) Object.defineProperty(r, z, {\n    value: t\n  });else if (t !== r[z]) throw new Error(\"Trying to cast object to subject type \" + t + \" but previously it was casted to \" + r[z]);\n  return r;\n}\nvar D = function t(r) {\n  var i = typeof r;\n  return i === \"string\" || i === \"function\";\n};\nvar L = function t(r) {\n  return r.modelName || r.name;\n};\nfunction N(t) {\n  return typeof t === \"string\" ? t : L(t);\n}\nfunction G(t) {\n  if (Object.hasOwn(t, z)) return t[z];\n  return L(t.constructor);\n}\nvar H = {\n  function: function t(r) {\n    return r.constructor;\n  },\n  string: G\n};\nfunction I(t, r, i) {\n  var n = q(r);\n  var e = 0;\n  while (e < n.length) {\n    var u = n[e++];\n    if (Object.hasOwn(t, u)) n = i(n, t[u]);\n  }\n  return n;\n}\nfunction J(t, r) {\n  if (typeof r === \"string\" && t.indexOf(r) !== -1) return r;\n  for (var i = 0; i < r.length; i++) if (t.indexOf(r[i]) !== -1) return r[i];\n  return null;\n}\nvar K = function t(r, i) {\n  return r.concat(i);\n};\nfunction Q(t, r) {\n  if (r in t) throw new Error('Cannot use \"' + r + \"\\\" as an alias because it's reserved action.\");\n  var i = Object.keys(t);\n  var n = function t(i, n) {\n    var e = J(i, n);\n    if (e) throw new Error(\"Detected cycle \" + e + \" -> \" + i.join(\", \"));\n    var u = typeof n === \"string\" && n === r || i.indexOf(r) !== -1 || Array.isArray(n) && n.indexOf(r) !== -1;\n    if (u) throw new Error('Cannot make an alias to \"' + r + '\" because this is reserved action');\n    return i.concat(n);\n  };\n  for (var e = 0; e < i.length; e++) I(t, i[e], n);\n}\nfunction U(t, r) {\n  if (!r || r.skipValidate !== false) Q(t, r && r.anyAction || \"manage\");\n  return function (r) {\n    return I(t, r, K);\n  };\n}\nfunction V(t, r, i) {\n  for (var n = i; n < r.length; n++) t.push(r[n]);\n}\nfunction W(t, r) {\n  if (!t || !t.length) return r || [];\n  if (!r || !r.length) return t || [];\n  var i = 0;\n  var n = 0;\n  var e = [];\n  while (i < t.length && n < r.length) if (t[i].priority < r[n].priority) {\n    e.push(t[i]);\n    i++;\n  } else {\n    e.push(r[n]);\n    n++;\n  }\n  V(e, t, i);\n  V(e, r, n);\n  return e;\n}\nfunction X(t, r, i) {\n  var n = t.get(r);\n  if (!n) {\n    n = i();\n    t.set(r, n);\n  }\n  return n;\n}\nvar Z = function t(r) {\n  return r;\n};\nfunction tt(t, r) {\n  if (Array.isArray(t.fields) && !t.fields.length) throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");\n  if (t.fields && !r.fieldMatcher) throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  if (t.conditions && !r.conditionsMatcher) throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n}\nvar rt = function () {\n  function t(t, r, i) {\n    if (i === void 0) i = 0;\n    tt(t, r);\n    this.action = r.resolveAction(t.action);\n    this.subject = t.subject;\n    this.inverted = !!t.inverted;\n    this.conditions = t.conditions;\n    this.reason = t.reason;\n    this.origin = t;\n    this.fields = t.fields ? q(t.fields) : void 0;\n    this.priority = i;\n    this.t = r;\n  }\n  var r = t.prototype;\n  r.i = function t() {\n    if (this.conditions && !this.u) this.u = this.t.conditionsMatcher(this.conditions);\n    return this.u;\n  };\n  r.matchesConditions = function t(r) {\n    if (!this.conditions) return true;\n    if (!r || D(r)) return !this.inverted;\n    var i = this.i();\n    return i(r);\n  };\n  r.matchesField = function t(r) {\n    if (!this.fields) return true;\n    if (!r) return !this.inverted;\n    if (this.fields && !this.o) this.o = this.t.fieldMatcher(this.fields);\n    return this.o(r);\n  };\n  P(t, [{\n    key: \"ast\",\n    get: function t() {\n      var r = this.i();\n      return r ? r.ast : void 0;\n    }\n  }]);\n  return t;\n}();\nfunction it(t, r) {\n  var i = {\n    value: t,\n    prev: r,\n    next: null\n  };\n  if (r) r.next = i;\n  return i;\n}\nfunction nt(t) {\n  if (t.next) t.next.prev = t.prev;\n  if (t.prev) t.prev.next = t.next;\n  t.next = t.prev = null;\n}\nvar et = function t(r) {\n  return {\n    value: r.value,\n    prev: r.prev,\n    next: r.next\n  };\n};\nvar ut = function t() {\n  return {\n    rules: [],\n    merged: false\n  };\n};\nvar ot = function t() {\n  return new Map();\n};\nvar ft = function () {\n  function t(t, r) {\n    if (t === void 0) t = [];\n    if (r === void 0) r = {};\n    this.h = false;\n    this.v = new Map();\n    this.l = {\n      conditionsMatcher: r.conditionsMatcher,\n      fieldMatcher: r.fieldMatcher,\n      resolveAction: r.resolveAction || Z\n    };\n    this.p = r.anyAction || \"manage\";\n    this.A = r.anySubjectType || \"all\";\n    this.j = t;\n    this.m = !!r.detectSubjectType;\n    this.M = r.detectSubjectType || G;\n    this.$(t);\n  }\n  var r = t.prototype;\n  r.detectSubjectType = function t(r) {\n    if (D(r)) return r;\n    if (!r) return this.A;\n    return this.M(r);\n  };\n  r.update = function t(r) {\n    var i = {\n      rules: r,\n      ability: this,\n      target: this\n    };\n    this.O(\"update\", i);\n    this.j = r;\n    this.$(r);\n    this.O(\"updated\", i);\n    return this;\n  };\n  r.$ = function t(r) {\n    var i = new Map();\n    var n;\n    for (var e = r.length - 1; e >= 0; e--) {\n      var u = r.length - e - 1;\n      var o = new rt(r[e], this.l, u);\n      var f = q(o.action);\n      var s = q(o.subject || this.A);\n      if (!this.h && o.fields) this.h = true;\n      for (var a = 0; a < s.length; a++) {\n        var c = X(i, s[a], ot);\n        if (n === void 0) n = typeof s[a];\n        if (typeof s[a] !== n && n !== \"mixed\") n = \"mixed\";\n        for (var h = 0; h < f.length; h++) X(c, f[h], ut).rules.push(o);\n      }\n    }\n    this.v = i;\n    if (n !== \"mixed\" && !this.m) {\n      var v = H[n] || H.string;\n      this.M = v;\n    }\n  };\n  r.possibleRulesFor = function t(r, i) {\n    if (i === void 0) i = this.A;\n    if (!D(i)) throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    var n = X(this.v, i, ot);\n    var e = X(n, r, ut);\n    if (e.merged) return e.rules;\n    var u = r !== this.p && n.has(this.p) ? n.get(this.p).rules : void 0;\n    var o = W(e.rules, u);\n    if (i !== this.A) o = W(o, this.possibleRulesFor(r, this.A));\n    e.rules = o;\n    e.merged = true;\n    return o;\n  };\n  r.rulesFor = function t(r, i, n) {\n    var e = this.possibleRulesFor(r, i);\n    if (n && typeof n !== \"string\") throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");\n    if (!this.h) return e;\n    return e.filter(function (t) {\n      return t.matchesField(n);\n    });\n  };\n  r.actionsFor = function t(r) {\n    if (!D(r)) throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');\n    var i = new Set();\n    var n = this.v.get(r);\n    if (n) Array.from(n.keys()).forEach(function (t) {\n      return i.add(t);\n    });\n    var e = r !== this.A ? this.v.get(this.A) : void 0;\n    if (e) Array.from(e.keys()).forEach(function (t) {\n      return i.add(t);\n    });\n    return Array.from(i);\n  };\n  r.on = function t(r, i) {\n    this.F = this.F || new Map();\n    var n = this.F;\n    var e = n.get(r) || null;\n    var u = it(i, e);\n    n.set(r, u);\n    return function () {\n      var t = n.get(r);\n      if (!u.next && !u.prev && t === u) n.delete(r);else if (u === t) n.set(r, u.prev);\n      nt(u);\n    };\n  };\n  r.O = function t(r, i) {\n    if (!this.F) return;\n    var n = this.F.get(r) || null;\n    while (n !== null) {\n      var e = n.prev ? et(n.prev) : null;\n      n.value(i);\n      n = e;\n    }\n  };\n  P(t, [{\n    key: \"rules\",\n    get: function t() {\n      return this.j;\n    }\n  }]);\n  return t;\n}();\nvar st = function (t) {\n  T(PureAbility, t);\n  function PureAbility() {\n    return t.apply(this, arguments) || this;\n  }\n  var r = PureAbility.prototype;\n  r.can = function t(r, i, n) {\n    var e = this.relevantRuleFor(r, i, n);\n    return !!e && !e.inverted;\n  };\n  r.relevantRuleFor = function t(r, i, n) {\n    var e = this.detectSubjectType(i);\n    var u = this.rulesFor(r, e, n);\n    for (var o = 0, f = u.length; o < f; o++) if (u[o].matchesConditions(i)) return u[o];\n    return null;\n  };\n  r.cannot = function t(r, i, n) {\n    return !this.can(r, i, n);\n  };\n  return PureAbility;\n}(ft);\nvar at = {\n  $eq: r,\n  $ne: i,\n  $lt: n,\n  $lte: e,\n  $gt: u,\n  $gte: o,\n  $in: f,\n  $nin: s,\n  $all: a,\n  $size: c,\n  $regex: h,\n  $options: v,\n  $elemMatch: l,\n  $exists: d\n};\nvar ct = {\n  eq: b,\n  ne: y,\n  lt: p,\n  lte: w,\n  gt: g,\n  gte: A,\n  in: j,\n  nin: m,\n  all: E,\n  size: M,\n  regex: $,\n  elemMatch: O,\n  exists: x,\n  and: F\n};\nvar ht = function r(i, n, e) {\n  return t(R({}, at, i), R({}, ct, n), e);\n};\nvar vt = t(at, ct);\nvar lt = /[-/\\\\^$+?.()|[\\]{}]/g;\nvar dt = /\\.?\\*+\\.?/g;\nvar bt = /\\*+/;\nvar yt = /\\./g;\nfunction pt(t, r, i) {\n  var n = i[0] === \"*\" || t[0] === \".\" && t[t.length - 1] === \".\" ? \"+\" : \"*\";\n  var e = t.indexOf(\"**\") === -1 ? \"[^.]\" : \".\";\n  var u = t.replace(yt, \"\\\\$&\").replace(bt, e + n);\n  return r + t.length === i.length ? \"(?:\" + u + \")?\" : u;\n}\nfunction wt(t, r, i) {\n  if (t === \".\" && (i[r - 1] === \"*\" || i[r + 1] === \"*\")) return t;\n  return \"\\\\\" + t;\n}\nfunction gt(t) {\n  var r = t.map(function (t) {\n    return t.replace(lt, wt).replace(dt, pt);\n  });\n  var i = r.length > 1 ? \"(?:\" + r.join(\"|\") + \")\" : r[0];\n  return new RegExp(\"^\" + i + \"$\");\n}\nvar At = function t(r) {\n  var i;\n  return function (t) {\n    if (typeof i === \"undefined\") i = r.every(function (t) {\n      return t.indexOf(\"*\") === -1;\n    }) ? null : gt(r);\n    return i === null ? r.indexOf(t) !== -1 : i.test(t);\n  };\n};\nvar jt = function (t) {\n  T(Ability, t);\n  function Ability(r, i) {\n    if (r === void 0) r = [];\n    if (i === void 0) i = {};\n    return t.call(this, r, R({\n      conditionsMatcher: vt,\n      fieldMatcher: At\n    }, i)) || this;\n  }\n  return Ability;\n}(st);\nfunction createMongoAbility(t, r) {\n  if (t === void 0) t = [];\n  if (r === void 0) r = {};\n  return new st(t, R({\n    conditionsMatcher: vt,\n    fieldMatcher: At\n  }, r));\n}\nfunction isAbilityClass(t) {\n  return typeof t.prototype.possibleRulesFor === \"function\";\n}\nvar mt = function () {\n  function t(t) {\n    this._ = t;\n  }\n  var r = t.prototype;\n  r.because = function t(r) {\n    this._.reason = r;\n    return this;\n  };\n  return t;\n}();\nvar Et = function () {\n  function AbilityBuilder(t) {\n    var r = this;\n    this.rules = [];\n    this.S = t;\n    this.can = function (t, i, n, e) {\n      return r.C(t, i, n, e, false);\n    };\n    this.cannot = function (t, i, n, e) {\n      return r.C(t, i, n, e, true);\n    };\n    this.build = function (t) {\n      return isAbilityClass(r.S) ? new r.S(r.rules, t) : r.S(r.rules, t);\n    };\n  }\n  var t = AbilityBuilder.prototype;\n  t.C = function t(r, i, n, e, u) {\n    var o = {\n      action: r\n    };\n    if (u) o.inverted = u;\n    if (i) {\n      o.subject = i;\n      if (Array.isArray(n) || typeof n === \"string\") o.fields = n;else if (typeof n !== \"undefined\") o.conditions = n;\n      if (typeof e !== \"undefined\") o.conditions = e;\n    }\n    this.rules.push(o);\n    return new mt(o);\n  };\n  return AbilityBuilder;\n}();\nfunction defineAbility(t, r) {\n  var i = new Et(createMongoAbility);\n  var n = t(i.can, i.cannot);\n  if (n && typeof n.then === \"function\") return n.then(function () {\n    return i.build(r);\n  });\n  return i.build(r);\n}\nvar Mt = function t(r) {\n  return 'Cannot execute \"' + r.action + '\" on \"' + r.subjectType + '\"';\n};\nvar $t = function t(r) {\n  this.message = r;\n};\n$t.prototype = Object.create(Error.prototype);\nvar Ot = function (t) {\n  T(ForbiddenError, t);\n  ForbiddenError.setDefaultMessage = function t(r) {\n    this.P = typeof r === \"string\" ? function () {\n      return r;\n    } : r;\n  };\n  ForbiddenError.from = function t(r) {\n    return new this(r);\n  };\n  function ForbiddenError(r) {\n    var i;\n    i = t.call(this, \"\") || this;\n    i.ability = r;\n    if (typeof Error.captureStackTrace === \"function\") {\n      i.name = \"ForbiddenError\";\n      Error.captureStackTrace(B(i), i.constructor);\n    }\n    return i;\n  }\n  var r = ForbiddenError.prototype;\n  r.setMessage = function t(r) {\n    this.message = r;\n    return this;\n  };\n  r.throwUnlessCan = function t(r, i, n) {\n    var e = this.unlessCan(r, i, n);\n    if (e) throw e;\n  };\n  r.unlessCan = function t(r, i, n) {\n    var e = this.ability.relevantRuleFor(r, i, n);\n    if (e && !e.inverted) return;\n    this.action = r;\n    this.subject = i;\n    this.subjectType = N(this.ability.detectSubjectType(i));\n    this.field = n;\n    var u = e ? e.reason : \"\";\n    this.message = this.message || u || this.constructor.P(this);\n    return this;\n  };\n  return ForbiddenError;\n}($t);\nOt.P = Mt;\nvar xt = Object.freeze({\n  __proto__: null\n});\nexport { jt as Ability, Et as AbilityBuilder, Ot as ForbiddenError, st as PureAbility, ht as buildMongoQueryMatcher, U as createAliasResolver, createMongoAbility, defineAbility, G as detectSubjectType, At as fieldPatternMatcher, Mt as getDefaultErrorMessage, xt as hkt, vt as mongoQueryMatcher, Y as subject, q as wrapArray };","map":{"version":3,"names":["q","t","Array","isArray","z","Y","r","Object","hasOwn","defineProperty","value","Error","D","i","L","modelName","name","N","G","constructor","H","function","string","I","n","e","length","u","J","indexOf","K","concat","Q","keys","join","U","skipValidate","anyAction","V","push","W","priority","X","get","set","Z","tt","fields","fieldMatcher","conditions","conditionsMatcher","rt","action","resolveAction","subject","inverted","reason","origin","prototype","matchesConditions","matchesField","o","P","key","ast","it","prev","next","nt","et","ut","rules","merged","ot","Map","ft","h","v","l","p","A","anySubjectType","j","m","detectSubjectType","M","$","update","ability","target","O","f","s","a","c","possibleRulesFor","has","rulesFor","filter","actionsFor","Set","from","forEach","add","on","F","delete","st","T","PureAbility","apply","arguments","can","relevantRuleFor","cannot","at","$eq","$ne","$lt","$lte","$gt","$gte","$in","$nin","$all","$size","$regex","$options","$elemMatch","$exists","d","ct","eq","b","ne","y","lt","lte","w","gt","g","gte","in","nin","all","E","size","regex","elemMatch","exists","x","and","ht","R","vt","dt","bt","yt","pt","replace","wt","map","RegExp","At","every","test","jt","Ability","call","createMongoAbility","isAbilityClass","mt","_","because","Et","AbilityBuilder","S","C","build","defineAbility","then","Mt","subjectType","$t","message","create","Ot","ForbiddenError","setDefaultMessage","captureStackTrace","B","setMessage","throwUnlessCan","unlessCan","field","xt","freeze","__proto__","buildMongoQueryMatcher","createAliasResolver","fieldPatternMatcher","getDefaultErrorMessage","hkt","mongoQueryMatcher","wrapArray"],"sources":["../../src/utils.ts","../../src/Rule.ts","../../src/structures/LinkedItem.ts","../../src/RuleIndex.ts","../../src/PureAbility.ts","../../src/matchers/conditions.ts","../../src/matchers/field.ts","../../src/Ability.ts","../../src/AbilityBuilder.ts","../../src/ForbiddenError.ts"],"sourcesContent":["import { AnyObject, Subject, SubjectType, SubjectClass, ForcedSubject, AliasesMap } from './types';\n\nexport function wrapArray<T>(value: T[] | T): T[] {\n  return Array.isArray(value) ? value : [value];\n}\n\nexport function setByPath(object: AnyObject, path: string, value: unknown): void {\n  let ref = object;\n  let lastKey = path;\n\n  if (path.indexOf('.') !== -1) {\n    const keys = path.split('.');\n\n    lastKey = keys.pop()!;\n    ref = keys.reduce((res, prop) => {\n      res[prop] = res[prop] || {};\n      return res[prop] as AnyObject;\n    }, object);\n  }\n\n  ref[lastKey] = value;\n}\n\nconst TYPE_FIELD = '__caslSubjectType__';\nexport function setSubjectType<\n  T extends string,\n  U extends Record<PropertyKey, any>\n>(type: T, object: U): U & ForcedSubject<T> {\n  if (object) {\n    if (!Object.hasOwn(object, TYPE_FIELD)) {\n      Object.defineProperty(object, TYPE_FIELD, { value: type });\n    } else if (type !== object[TYPE_FIELD]) {\n      throw new Error(`Trying to cast object to subject type ${type} but previously it was casted to ${object[TYPE_FIELD]}`);\n    }\n  }\n\n  return object as U & ForcedSubject<T>;\n}\n\nexport const isSubjectType = (value: unknown): value is SubjectType => {\n  const type = typeof value;\n  return type === 'string' || type === 'function';\n};\n\nconst getSubjectClassName = (value: SubjectClass) => value.modelName || value.name;\nexport function getSubjectTypeName(value: SubjectType) {\n  return typeof value === 'string' ? value : getSubjectClassName(value);\n}\n\nexport function detectSubjectType(object: Exclude<Subject, SubjectType>): string {\n  if (Object.hasOwn(object, TYPE_FIELD)) {\n    return object[TYPE_FIELD];\n  }\n\n  return getSubjectClassName(object.constructor as SubjectClass);\n}\n\nexport const DETECT_SUBJECT_TYPE_STRATEGY = {\n  function: (object: Exclude<Subject, SubjectType>) => object.constructor as SubjectClass,\n  string: detectSubjectType\n};\n\ntype AliasMerge = (actions: string[], action: string | string[]) => string[];\nfunction expandActions(aliasMap: AliasesMap, rawActions: string | string[], merge: AliasMerge) {\n  let actions = wrapArray(rawActions);\n  let i = 0;\n\n  while (i < actions.length) {\n    const action = actions[i++];\n\n    if (Object.hasOwn(aliasMap, action)) {\n      actions = merge(actions, aliasMap[action]);\n    }\n  }\n\n  return actions;\n}\n\nfunction findDuplicate(actions: string[], actionToFind: string | string[]) {\n  if (typeof actionToFind === 'string' && actions.indexOf(actionToFind) !== -1) {\n    return actionToFind;\n  }\n\n  for (let i = 0; i < actionToFind.length; i++) {\n    if (actions.indexOf(actionToFind[i]) !== -1) return actionToFind[i];\n  }\n\n  return null;\n}\n\nconst defaultAliasMerge: AliasMerge = (actions, action) => actions.concat(action);\nfunction validateForCycles(aliasMap: AliasesMap, reservedAction: string) {\n  if (reservedAction in aliasMap) {\n    throw new Error(`Cannot use \"${reservedAction}\" as an alias because it's reserved action.`);\n  }\n\n  const keys = Object.keys(aliasMap);\n  const mergeAliasesAndDetectCycles: AliasMerge = (actions, action) => {\n    const duplicate = findDuplicate(actions, action);\n    if (duplicate) throw new Error(`Detected cycle ${duplicate} -> ${actions.join(', ')}`);\n\n    const isUsingReservedAction = typeof action === 'string' && action === reservedAction\n      || actions.indexOf(reservedAction) !== -1\n      || Array.isArray(action) && action.indexOf(reservedAction) !== -1;\n    if (isUsingReservedAction) throw new Error(`Cannot make an alias to \"${reservedAction}\" because this is reserved action`);\n\n    return actions.concat(action);\n  };\n\n  for (let i = 0; i < keys.length; i++) {\n    expandActions(aliasMap, keys[i], mergeAliasesAndDetectCycles);\n  }\n}\n\nexport type AliasResolverOptions = { skipValidate?: boolean; anyAction?: string };\nexport function createAliasResolver(aliasMap: AliasesMap, options?: AliasResolverOptions) {\n  if (!options || options.skipValidate !== false) {\n    validateForCycles(aliasMap, options && options.anyAction || 'manage');\n  }\n\n  return (action: string | string[]) => expandActions(aliasMap, action, defaultAliasMerge);\n}\n\nfunction copyArrayTo<T>(dest: T[], target: T[], start: number) {\n  for (let i = start; i < target.length; i++) {\n    dest.push(target[i]);\n  }\n}\n\nexport function mergePrioritized<T extends { priority: number }>(\n  array?: T[],\n  anotherArray?: T[]\n): T[] {\n  if (!array || !array.length) {\n    return anotherArray || [];\n  }\n\n  if (!anotherArray || !anotherArray.length) {\n    return array || [];\n  }\n\n  let i = 0;\n  let j = 0;\n  const merged: T[] = [];\n\n  while (i < array.length && j < anotherArray.length) {\n    if (array[i].priority < anotherArray[j].priority) {\n      merged.push(array[i]);\n      i++;\n    } else {\n      merged.push(anotherArray[j]);\n      j++;\n    }\n  }\n\n  copyArrayTo(merged, array, i);\n  copyArrayTo(merged, anotherArray, j);\n\n  return merged;\n}\n\nexport function getOrDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  let value = map.get(key);\n\n  if (!value) {\n    value = defaultValue();\n    map.set(key, value);\n  }\n\n  return value;\n}\n\nexport const identity = <T>(x: T) => x;\n","import { wrapArray, isSubjectType } from './utils';\nimport {\n  MatchConditions,\n  MatchField,\n  Abilities,\n  ToAbilityTypes,\n  Normalize,\n  ConditionsMatcher,\n  FieldMatcher,\n} from './types';\nimport { RawRule, RawRuleFrom } from './RawRule';\n\ntype Tuple<A extends Abilities> = Normalize<ToAbilityTypes<A>>;\n\nfunction validate(rule: RawRuleFrom<Abilities, any>, options: RuleOptions<any>) {\n  if (Array.isArray(rule.fields) && !rule.fields.length) {\n    throw new Error('`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa');\n  }\n\n  if (rule.fields && !options.fieldMatcher) {\n    throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  }\n\n  if (rule.conditions && !options.conditionsMatcher) {\n    throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n  }\n}\n\nexport interface RuleOptions<Conditions> {\n  conditionsMatcher?: ConditionsMatcher<Conditions>\n  fieldMatcher?: FieldMatcher\n  resolveAction(action: string | string[]): string | string[]\n}\n\nexport class Rule<A extends Abilities, C> {\n  private _matchConditions: MatchConditions | undefined;\n  private _matchField: MatchField<string> | undefined;\n  private readonly _options!: RuleOptions<C>;\n  public readonly action!: Tuple<A>[0] | Tuple<A>[0][];\n  public readonly subject!: Tuple<A>[1] | Tuple<A>[1][];\n  public readonly inverted!: boolean;\n  public readonly conditions!: C | undefined;\n  public readonly fields!: string[] | undefined;\n  public readonly reason!: string | undefined;\n  public readonly origin!: RawRule<ToAbilityTypes<A>, C>;\n  public readonly priority!: number;\n\n  constructor(\n    rule: RawRule<ToAbilityTypes<A>, C>,\n    options: RuleOptions<C>,\n    priority: number = 0\n  ) {\n    validate(rule, options);\n\n    this.action = options.resolveAction(rule.action);\n    this.subject = rule.subject!;\n    this.inverted = !!rule.inverted;\n    this.conditions = rule.conditions;\n    this.reason = rule.reason;\n    this.origin = rule;\n    this.fields = rule.fields ? wrapArray(rule.fields) : undefined;\n    this.priority = priority;\n    this._options = options;\n  }\n\n  private _conditionsMatcher() {\n    if (this.conditions && !this._matchConditions) {\n      this._matchConditions = this._options.conditionsMatcher!(this.conditions);\n    }\n\n    return this._matchConditions!;\n  }\n\n  get ast() {\n    const matches = this._conditionsMatcher();\n    return matches ? matches.ast : undefined;\n  }\n\n  matchesConditions(object: Normalize<A>[1] | undefined): boolean {\n    if (!this.conditions) {\n      return true;\n    }\n\n    if (!object || isSubjectType(object)) {\n      return !this.inverted;\n    }\n\n    const matches = this._conditionsMatcher();\n    return matches(object as Record<string, unknown>);\n  }\n\n  matchesField(field: string | undefined): boolean {\n    if (!this.fields) {\n      return true;\n    }\n\n    if (!field) {\n      return !this.inverted;\n    }\n\n    if (this.fields && !this._matchField) {\n      this._matchField = this._options.fieldMatcher!(this.fields);\n    }\n\n    return this._matchField!(field);\n  }\n}\n","export interface LinkedItem<T> {\n  next: LinkedItem<T> | null\n  prev: LinkedItem<T> | null\n  readonly value: T\n}\n\nexport function linkedItem<T>(value: T, prev: LinkedItem<T>['prev']) {\n  const item = { value, prev, next: null };\n\n  if (prev) {\n    prev.next = item;\n  }\n\n  return item;\n}\n\nexport function unlinkItem(item: LinkedItem<any>) {\n  if (item.next) {\n    item.next.prev = item.prev;\n  }\n\n  if (item.prev) {\n    item.prev.next = item.next;\n  }\n\n  item.next = item.prev = null; // eslint-disable-line\n}\n\nexport const cloneLinkedItem = <T extends LinkedItem<any>>(item: T): T => ({\n  value: item.value,\n  prev: item.prev,\n  next: item.next,\n} as T);\n","import { Rule, RuleOptions } from './Rule';\nimport { RawRuleFrom } from './RawRule';\nimport {\n  Abilities,\n  Normalize,\n  SubjectType,\n  AbilityParameters,\n  AbilityTuple,\n  ExtractSubjectType\n} from './types';\nimport { wrapArray, detectSubjectType, mergePrioritized, getOrDefault, identity, isSubjectType, DETECT_SUBJECT_TYPE_STRATEGY } from './utils';\nimport { LinkedItem, linkedItem, unlinkItem, cloneLinkedItem } from './structures/LinkedItem';\n\nexport interface RuleIndexOptions<A extends Abilities, C> extends Partial<RuleOptions<C>> {\n  detectSubjectType?(\n    subject: Exclude<Normalize<A>[1], SubjectType>\n  ): ExtractSubjectType<Normalize<A>[1]>;\n  anyAction?: string;\n  anySubjectType?: string;\n}\n\nexport declare const ɵabilities: unique symbol;\nexport declare const ɵconditions: unique symbol;\ninterface WithGenerics {\n  [ɵabilities]: any\n  [ɵconditions]: any\n}\nexport type Public<T extends WithGenerics> = { [K in keyof T]: T[K] };\nexport interface Generics<T extends WithGenerics> {\n  abilities: T[typeof ɵabilities],\n  conditions: T[typeof ɵconditions]\n}\n\nexport type RuleOf<T extends WithGenerics> =\n  Rule<Generics<T>['abilities'], Generics<T>['conditions']>;\nexport type RawRuleOf<T extends WithGenerics> =\n  RawRuleFrom<Generics<T>['abilities'], Generics<T>['conditions']>;\n\nexport type RuleIndexOptionsOf<T extends WithGenerics> =\n  RuleIndexOptions<Generics<T>['abilities'], Generics<T>['conditions']>;\n\ninterface AbilityEvent<T extends WithGenerics> {\n  target: T\n  /** @deprecated use \"target\" property instead */\n  ability: T\n}\n\nexport interface UpdateEvent<T extends WithGenerics> extends AbilityEvent<T> {\n  rules: RawRuleOf<T>[]\n}\n/**\n * @deprecated `on`/`emit` properly infer type without this type\n * TODO(major): delete\n */\nexport type EventHandler<Event> = (event: Event) => void;\n\nexport type Events<\n  T extends WithGenerics,\n  K extends keyof EventsMap<T> = keyof EventsMap<T>\n> = Map<K, LinkedItem<EventsMap<T>[K]> | null>;\n\ninterface EventsMap<T extends WithGenerics> {\n  update(event: UpdateEvent<T>): void\n  updated(event: UpdateEvent<T>): void\n}\n\ntype IndexTree<A extends Abilities, C> = Map<SubjectType, Map<string, {\n  rules: Rule<A, C>[],\n  merged: boolean\n}>>;\n\nexport type Unsubscribe = () => void;\n\nconst defaultActionEntry = () => ({\n  rules: [] as unknown as Rule<any, any>[],\n  merged: false\n});\nconst defaultSubjectEntry = () => new Map<string, ReturnType<typeof defaultActionEntry>>();\n\ntype AbilitySubjectTypeParameters<T extends Abilities, IncludeField extends boolean = true> =\n  AbilityParameters<\n  T,\n  T extends AbilityTuple\n    ? IncludeField extends true\n      ? (action: T[0], subject: ExtractSubjectType<T[1]>, field?: string) => 0\n      : (action: T[0], subject: ExtractSubjectType<T[1]>) => 0\n    : never,\n  (action: Extract<T, string>) => 0\n  >;\n\nexport class RuleIndex<A extends Abilities, Conditions> {\n  private _hasPerFieldRules: boolean = false;\n  private _events?: Events<this>;\n  private _indexedRules: IndexTree<A, Conditions> = new Map();\n  private _rules: RawRuleFrom<A, Conditions>[];\n  private readonly _ruleOptions: RuleOptions<Conditions>;\n  private _detectSubjectType: this['detectSubjectType'];\n  private readonly _anyAction: string;\n  private readonly _anySubjectType: string;\n  private readonly _hasCustomSubjectTypeDetection: boolean;\n  readonly [ɵabilities]!: A;\n  readonly [ɵconditions]!: Conditions;\n\n  constructor(\n    rules: RawRuleFrom<A, Conditions>[] = [],\n    options: RuleIndexOptions<A, Conditions> = {}\n  ) {\n    this._ruleOptions = {\n      conditionsMatcher: options.conditionsMatcher,\n      fieldMatcher: options.fieldMatcher,\n      resolveAction: options.resolveAction || identity,\n    };\n    this._anyAction = options.anyAction || 'manage';\n    this._anySubjectType = options.anySubjectType || 'all';\n    this._rules = rules;\n    this._hasCustomSubjectTypeDetection = !!options.detectSubjectType;\n    this._detectSubjectType = options.detectSubjectType || (detectSubjectType as this['detectSubjectType']);\n    this._indexAndAnalyzeRules(rules);\n  }\n\n  get rules() {\n    return this._rules;\n  }\n\n  detectSubjectType(object?: Normalize<A>[1]): ExtractSubjectType<Normalize<A>[1]> {\n    if (isSubjectType(object)) return object as ExtractSubjectType<Normalize<A>[1]>;\n    if (!object) return this._anySubjectType as ExtractSubjectType<Normalize<A>[1]>;\n    return this._detectSubjectType(object as Exclude<Normalize<A>[1], SubjectType>);\n  }\n\n  update(rules: RawRuleFrom<A, Conditions>[]): Public<this> {\n    const event = {\n      rules,\n      ability: this,\n      target: this\n    } as unknown as UpdateEvent<this>;\n\n    this._emit('update', event);\n    this._rules = rules;\n    this._indexAndAnalyzeRules(rules);\n    this._emit('updated', event);\n\n    return this;\n  }\n\n  private _indexAndAnalyzeRules(rawRules: RawRuleFrom<A, Conditions>[]) {\n    const indexedRules: IndexTree<A, Conditions> = new Map();\n    let typeOfSubjectType: string | undefined;\n\n    for (let i = rawRules.length - 1; i >= 0; i--) {\n      const priority = rawRules.length - i - 1;\n      const rule = new Rule(rawRules[i], this._ruleOptions, priority);\n      const actions = wrapArray(rule.action);\n      const subjects = wrapArray(rule.subject || this._anySubjectType);\n      if (!this._hasPerFieldRules && rule.fields) this._hasPerFieldRules = true;\n\n      for (let k = 0; k < subjects.length; k++) {\n        const subjectRules = getOrDefault(indexedRules, subjects[k], defaultSubjectEntry);\n        if (typeOfSubjectType === undefined) {\n          typeOfSubjectType = typeof subjects[k];\n        }\n        if (typeof subjects[k] !== typeOfSubjectType && typeOfSubjectType !== 'mixed') {\n          typeOfSubjectType = 'mixed';\n        }\n\n        for (let j = 0; j < actions.length; j++) {\n          getOrDefault(subjectRules, actions[j], defaultActionEntry).rules.push(rule);\n        }\n      }\n    }\n\n    this._indexedRules = indexedRules;\n    if (typeOfSubjectType !== 'mixed' && !this._hasCustomSubjectTypeDetection) {\n      const detectSubjectType = DETECT_SUBJECT_TYPE_STRATEGY[typeOfSubjectType as 'function' | 'string'] || DETECT_SUBJECT_TYPE_STRATEGY.string;\n      this._detectSubjectType = detectSubjectType as this['detectSubjectType'];\n    }\n  }\n\n  possibleRulesFor(...args: AbilitySubjectTypeParameters<A, false>): Rule<A, Conditions>[];\n  possibleRulesFor(\n    action: string,\n    subjectType: SubjectType = this._anySubjectType\n  ): Rule<A, Conditions>[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    }\n\n    const subjectRules = getOrDefault(this._indexedRules, subjectType, defaultSubjectEntry);\n    const actionRules = getOrDefault(subjectRules, action, defaultActionEntry);\n\n    if (actionRules.merged) {\n      return actionRules.rules;\n    }\n\n    const anyActionRules = action !== this._anyAction && subjectRules.has(this._anyAction)\n      ? subjectRules.get(this._anyAction)!.rules\n      : undefined;\n    let rules = mergePrioritized(actionRules.rules, anyActionRules);\n\n    if (subjectType !== this._anySubjectType) {\n      rules = mergePrioritized(rules, (this as any).possibleRulesFor(action, this._anySubjectType));\n    }\n\n    actionRules.rules = rules;\n    actionRules.merged = true;\n\n    return rules;\n  }\n\n  rulesFor(...args: AbilitySubjectTypeParameters<A>): Rule<A, Conditions>[];\n  rulesFor(action: string, subjectType?: SubjectType, field?: string): Rule<A, Conditions>[] {\n    const rules: Rule<A, Conditions>[] = (this as any).possibleRulesFor(action, subjectType);\n\n    if (field && typeof field !== 'string') {\n      throw new Error('The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details');\n    }\n\n    if (!this._hasPerFieldRules) {\n      return rules;\n    }\n\n    return rules.filter(rule => rule.matchesField(field));\n  }\n\n  actionsFor(subjectType: ExtractSubjectType<Normalize<A>[1]>): string[] {\n    if (!isSubjectType(subjectType)) {\n      throw new Error('\"actionsFor\" accepts only subject types (i.e., string or class) as a parameter');\n    }\n\n    const actions = new Set<string>();\n\n    const subjectRules = this._indexedRules.get(subjectType);\n    if (subjectRules) {\n      Array.from(subjectRules.keys()).forEach(action => actions.add(action));\n    }\n\n    const anySubjectTypeRules = subjectType !== this._anySubjectType\n      ? this._indexedRules.get(this._anySubjectType)\n      : undefined;\n    if (anySubjectTypeRules) {\n      Array.from(anySubjectTypeRules.keys()).forEach(action => actions.add(action));\n    }\n\n    return Array.from(actions);\n  }\n\n  on<T extends keyof EventsMap<this>>(\n    event: T,\n    handler: EventsMap<Public<this>>[T]\n  ): Unsubscribe {\n    this._events = this._events || new Map();\n    const events = this._events;\n    const tail = events.get(event) || null;\n    const item = linkedItem(handler, tail);\n    events.set(event, item);\n\n    return () => {\n      const currentTail = events.get(event);\n\n      if (!item.next && !item.prev && currentTail === item) {\n        events.delete(event);\n      } else if (item === currentTail) {\n        events.set(event, item.prev);\n      }\n\n      unlinkItem(item);\n    };\n  }\n\n  private _emit<T extends keyof EventsMap<this>>(\n    name: T,\n    payload: Parameters<EventsMap<this>[T]>[0]\n  ) {\n    if (!this._events) return;\n\n    let current = this._events.get(name) || null;\n    while (current !== null) {\n      const prev = current.prev ? cloneLinkedItem(current.prev) : null;\n      current.value(payload);\n      current = prev;\n    }\n  }\n}\n","import { RuleIndex, RuleIndexOptions, RuleIndexOptionsOf, Public, RawRuleOf } from './RuleIndex';\nimport { Abilities, AbilityTuple, CanParameters, Subject } from './types';\nimport { Rule } from './Rule';\n\nexport interface AbilityOptions<A extends Abilities, Conditions>\n  extends RuleIndexOptions<A, Conditions> {}\nexport interface AnyAbility extends Public<PureAbility<any, any>> {}\nexport interface AbilityOptionsOf<T extends AnyAbility> extends RuleIndexOptionsOf<T> {}\n\nexport type AbilityClass<T extends AnyAbility> = new (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport type CreateAbility<T extends AnyAbility> = (\n  rules?: RawRuleOf<T>[],\n  options?: AbilityOptionsOf<T>\n) => T;\n\nexport class PureAbility<\n  A extends Abilities = AbilityTuple,\n  Conditions = unknown\n> extends RuleIndex<A, Conditions> {\n  can(...args: CanParameters<A>): boolean;\n  can(action: string, subject?: Subject, field?: string): boolean {\n    const rule = (this as PrimitiveAbility).relevantRuleFor(action, subject, field);\n    return !!rule && !rule.inverted;\n  }\n\n  relevantRuleFor(...args: CanParameters<A>): Rule<A, Conditions> | null;\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null {\n    const subjectType = this.detectSubjectType(subject);\n    const rules = (this as any).rulesFor(action, subjectType, field);\n\n    for (let i = 0, length = rules.length; i < length; i++) {\n      if (rules[i].matchesConditions(subject)) {\n        return rules[i];\n      }\n    }\n\n    return null;\n  }\n\n  cannot(...args: CanParameters<A>): boolean;\n  cannot(action: string, subject?: Subject, field?: string): boolean {\n    return !(this as PrimitiveAbility).can(action, subject, field);\n  }\n}\n\n/**\n * helper interface that helps to emit js methods that have static parameters\n */\ninterface PrimitiveAbility<A extends Abilities = AbilityTuple, Conditions = unknown> {\n  can(action: string, subject?: Subject, field?: string): boolean;\n  relevantRuleFor(action: string, subject?: Subject, field?: string): Rule<A, Conditions> | null\n}\n","import {\n  $eq,\n  eq,\n  $ne,\n  ne,\n  $lt,\n  lt,\n  $lte,\n  lte,\n  $gt,\n  gt,\n  $gte,\n  gte,\n  $in,\n  within,\n  $nin,\n  nin,\n  $all,\n  all,\n  $size,\n  size,\n  $regex,\n  $options,\n  regex,\n  $elemMatch,\n  elemMatch,\n  $exists,\n  exists,\n  and,\n  createFactory,\n  BuildMongoQuery,\n  DefaultOperators,\n} from '@ucast/mongo2js';\nimport { ConditionsMatcher, AnyObject } from '../types';\nimport { Container, GenericFactory } from '../hkt';\n\nconst defaultInstructions = {\n  $eq,\n  $ne,\n  $lt,\n  $lte,\n  $gt,\n  $gte,\n  $in,\n  $nin,\n  $all,\n  $size,\n  $regex,\n  $options,\n  $elemMatch,\n  $exists,\n};\nconst defaultInterpreters = {\n  eq,\n  ne,\n  lt,\n  lte,\n  gt,\n  gte,\n  in: within,\n  nin,\n  all,\n  size,\n  regex,\n  elemMatch,\n  exists,\n  and,\n};\n\ninterface MongoQueryFactory extends GenericFactory {\n  produce: MongoQuery<this[0]>\n}\n\ntype MergeUnion<T, Keys extends keyof T = keyof T> = { [K in Keys]: T[K] };\nexport type MongoQuery<T = AnyObject> = BuildMongoQuery<MergeUnion<T>, {\n  toplevel: {},\n  field: Pick<DefaultOperators<MergeUnion<T>>['field'], keyof typeof defaultInstructions>\n}> & Container<MongoQueryFactory>;\n\ntype MongoQueryMatcherFactory =\n  (...args: Partial<Parameters<typeof createFactory>>) => ConditionsMatcher<MongoQuery>;\nexport const buildMongoQueryMatcher = ((instructions, interpreters, options) => createFactory(\n  { ...defaultInstructions, ...instructions },\n  { ...defaultInterpreters, ...interpreters },\n  options\n)) as MongoQueryMatcherFactory;\n\nexport const mongoQueryMatcher = createFactory(defaultInstructions, defaultInterpreters);\nexport type {\n  MongoQueryFieldOperators,\n  MongoQueryTopLevelOperators,\n  MongoQueryOperators,\n} from '@ucast/mongo2js';\n","import { FieldMatcher } from '../types';\n\nconst REGEXP_SPECIAL_CHARS = /[-/\\\\^$+?.()|[\\]{}]/g;\nconst REGEXP_ANY = /\\.?\\*+\\.?/g;\nconst REGEXP_STARS = /\\*+/;\nconst REGEXP_DOT = /\\./g;\n\nfunction detectRegexpPattern(match: string, index: number, string: string): string {\n  const quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.'\n    ? '+'\n    : '*';\n  const matcher = match.indexOf('**') === -1 ? '[^.]' : '.';\n  const pattern = match.replace(REGEXP_DOT, '\\\\$&')\n    .replace(REGEXP_STARS, matcher + quantifier);\n\n  return index + match.length === string.length ? `(?:${pattern})?` : pattern;\n}\n\nfunction escapeRegexp(match: string, index: number, string: string): string {\n  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {\n    return match;\n  }\n\n  return `\\\\${match}`;\n}\n\nfunction createPattern(fields: string[]) {\n  const patterns = fields.map(field => field\n    .replace(REGEXP_SPECIAL_CHARS, escapeRegexp)\n    .replace(REGEXP_ANY, detectRegexpPattern));\n  const pattern = patterns.length > 1 ? `(?:${patterns.join('|')})` : patterns[0];\n\n  return new RegExp(`^${pattern}$`);\n}\n\nexport const fieldPatternMatcher: FieldMatcher = (fields) => {\n  let pattern: RegExp | null;\n\n  return (field) => {\n    if (typeof pattern === 'undefined') {\n      pattern = fields.every(f => f.indexOf('*') === -1)\n        ? null\n        : createPattern(fields);\n    }\n\n    return pattern === null\n      ? fields.indexOf(field) !== -1\n      : pattern.test(field);\n  };\n};\n","import { PureAbility, AbilityOptions, AbilityOptionsOf } from './PureAbility';\nimport { RawRuleFrom } from './RawRule';\nimport { AbilityTuple } from './types';\nimport { MongoQuery, mongoQueryMatcher } from './matchers/conditions';\nimport { fieldPatternMatcher } from './matchers/field';\nimport { Public, RawRuleOf } from './RuleIndex';\n\n/**\n * @deprecated use createMongoAbility function instead and MongoAbility<Abilities> interface.\n * In the next major version PureAbility will be renamed to Ability and this class will be removed\n */\nexport class Ability<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {\n  constructor(rules: RawRuleFrom<A, C>[] = [], options: AbilityOptions<A, C> = {}) {\n    super(rules, {\n      conditionsMatcher: mongoQueryMatcher,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n\nexport interface AnyMongoAbility extends Public<PureAbility<any, MongoQuery>> {}\nexport interface MongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n> extends PureAbility<A, C> {}\n\n/**\n * Creates Ability with MongoDB conditions matcher\n */\nexport function createMongoAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(rules?: RawRuleOf<T>[], options?: AbilityOptionsOf<T>): T;\nexport function createMongoAbility<\n  A extends AbilityTuple = AbilityTuple,\n  C extends MongoQuery = MongoQuery\n>(rules?: RawRuleFrom<A, C>[], options?: AbilityOptions<A, C>): MongoAbility<A, C>;\nexport function createMongoAbility(rules: any[] = [], options = {}): AnyMongoAbility {\n  return new PureAbility(rules, {\n    conditionsMatcher: mongoQueryMatcher,\n    fieldMatcher: fieldPatternMatcher,\n    ...options,\n  });\n}\n","import { AnyMongoAbility, createMongoAbility, MongoAbility } from './Ability';\nimport { ProduceGeneric } from './hkt';\nimport { AbilityOptionsOf, AnyAbility } from './PureAbility';\nimport { Generics, RawRuleOf } from './RuleIndex';\nimport {\n  AbilityTuple, AnyClass, AnyObject, ExtractSubjectType as E, Normalize, SubjectType,\n  TaggedInterface\n} from './types';\n\nfunction isAbilityClass(factory: AbilityFactory<any>): factory is AnyClass {\n  return typeof factory.prototype.possibleRulesFor === 'function';\n}\n\nclass RuleBuilder<T extends AnyAbility> {\n  public _rule!: RawRuleOf<T>;\n\n  constructor(rule: RawRuleOf<T>) {\n    this._rule = rule;\n  }\n\n  because(reason: string): this {\n    this._rule.reason = reason;\n    return this;\n  }\n}\n\ntype AbilityFactory<T extends AnyAbility> = AnyClass<T> | ((rules?: any[], options?: any) => T);\ntype InstanceOf<T extends AnyAbility, S extends SubjectType> = S extends AnyClass<infer R>\n  ? R\n  : S extends (...args: any[]) => infer O\n    ? O\n    : S extends string\n      ? Exclude<Normalize<Generics<T>['abilities']>[1], SubjectType> extends TaggedInterface<string>\n        ? Extract<Normalize<Generics<T>['abilities']>[1], TaggedInterface<S>>\n        : AnyObject\n      : never;\ntype ConditionsOf<T extends AnyAbility, I extends {}> =\n  ProduceGeneric<Generics<T>['conditions'], I>;\ntype ActionFrom<T extends AbilityTuple, S extends SubjectType> = T extends any\n  ? S extends Extract<T[1], SubjectType> ? T[0] : never\n  : never;\ntype ActionOf<T extends AnyAbility, S extends SubjectType> = ActionFrom<Generics<T>['abilities'], S>;\ntype SubjectTypeOf<T extends AnyAbility> = E<Normalize<Generics<T>['abilities']>[1]>;\n\ntype SimpleCanParams<T extends AnyAbility> = Parameters<(\n  action: Generics<T>['abilities'] | Generics<T>['abilities'][]\n) => 0>;\ntype BuilderCanParameters<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\n\ntype BuilderCanParametersWithFields<\n  S extends SubjectType,\n  I extends InstanceOf<T, S>,\n  F extends string,\n  T extends AnyAbility\n> = Generics<T>['abilities'] extends AbilityTuple\n  ? Parameters<(\n    action: ActionOf<T, S> | ActionOf<T, S>[],\n    subject: S | S[],\n    fields?: F | F[],\n    conditions?: ConditionsOf<T, I>\n  ) => 0>\n  : SimpleCanParams<T>;\ntype Keys<T> = string & keyof T;\n\ntype AddRule<T extends AnyAbility> = {\n  <\n    I extends InstanceOf<T, S>,\n    F extends string = Keys<I>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParametersWithFields<S, I, F | Keys<I>, T>): RuleBuilder<T>;\n  <\n    I extends InstanceOf<T, S>,\n    S extends SubjectTypeOf<T> = SubjectTypeOf<T>\n  >(...args: BuilderCanParameters<S, I, T>): RuleBuilder<T>;\n};\n\nexport class AbilityBuilder<T extends AnyAbility> {\n  public rules: RawRuleOf<T>[] = [];\n  private readonly _createAbility: AbilityFactory<T>;\n  public can: AddRule<T>;\n  public cannot: AddRule<T>;\n  public build: (options?: AbilityOptionsOf<T>) => T;\n\n  constructor(AbilityType: AbilityFactory<T>) {\n    this._createAbility = AbilityType;\n\n    this.can = (\n      action: string | string[],\n      subject?: SubjectType | SubjectType[],\n      conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n      conditions?: Generics<T>['conditions']\n    ) => this._addRule(action, subject, conditionsOrFields, conditions, false);\n    this.cannot = (\n      action: string | string[],\n      subject?: SubjectType | SubjectType[],\n      conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n      conditions?: Generics<T>['conditions']\n    ) => this._addRule(action, subject, conditionsOrFields, conditions, true);\n\n    this.build = options => (isAbilityClass(this._createAbility)\n      ? new this._createAbility(this.rules, options)\n      : this._createAbility(this.rules, options));\n  }\n\n  private _addRule(\n    action: string | string[],\n    subject?: SubjectType | SubjectType[],\n    conditionsOrFields?: string | string[] | Generics<T>['conditions'],\n    conditions?: Generics<T>['conditions'],\n    inverted?: boolean\n  ): RuleBuilder<T> {\n    const rule = { action } as RawRuleOf<T>;\n\n    if (inverted) rule.inverted = inverted;\n    if (subject) {\n      rule.subject = subject;\n\n      if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {\n        rule.fields = conditionsOrFields;\n      } else if (typeof conditionsOrFields !== 'undefined') {\n        rule.conditions = conditionsOrFields;\n      }\n\n      if (typeof conditions !== 'undefined') {\n        rule.conditions = conditions;\n      }\n    }\n\n    this.rules.push(rule);\n    return new RuleBuilder(rule);\n  }\n}\n\ntype DSL<T extends AnyAbility, R> = (\n  can: AbilityBuilder<T>['can'],\n  cannot: AbilityBuilder<T>['cannot']\n) => R;\n\nexport function defineAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(define: DSL<T, Promise<void>>, options?: AbilityOptionsOf<T>): Promise<T>;\nexport function defineAbility<\n  T extends AnyMongoAbility = MongoAbility\n>(define: DSL<T, void>, options?: AbilityOptionsOf<T>): T;\nexport function defineAbility<\n  T extends AnyMongoAbility\n>(define: DSL<T, void | Promise<void>>, options?: AbilityOptionsOf<T>): T | Promise<T> {\n  const builder = new AbilityBuilder<T>(createMongoAbility);\n  const result = define(builder.can, builder.cannot);\n\n  if (result && typeof result.then === 'function') {\n    return result.then(() => builder.build(options));\n  }\n\n  return builder.build(options);\n}\n","import { AnyAbility } from './PureAbility';\nimport { Normalize, Subject } from './types';\nimport { Generics } from './RuleIndex';\nimport { getSubjectTypeName } from './utils';\n\nexport type GetErrorMessage = (error: ForbiddenError<AnyAbility>) => string;\n/** @deprecated will be removed in the next major release */\nexport const getDefaultErrorMessage: GetErrorMessage = error => `Cannot execute \"${error.action}\" on \"${error.subjectType}\"`;\n\nconst NativeError = function NError(this: Error, message: string) {\n  this.message = message;\n} as unknown as new (message: string) => Error;\n\nNativeError.prototype = Object.create(Error.prototype);\n\nexport class ForbiddenError<T extends AnyAbility> extends NativeError {\n  public readonly ability!: T;\n  public action!: Normalize<Generics<T>['abilities']>[0];\n  public subject!: Generics<T>['abilities'][1];\n  public field?: string;\n  public subjectType!: string;\n\n  static _defaultErrorMessage = getDefaultErrorMessage;\n\n  static setDefaultMessage(messageOrFn: string | GetErrorMessage) {\n    this._defaultErrorMessage = typeof messageOrFn === 'string' ? () => messageOrFn : messageOrFn;\n  }\n\n  static from<U extends AnyAbility>(ability: U): ForbiddenError<U> {\n    return new this<U>(ability);\n  }\n\n  private constructor(ability: T) {\n    super('');\n    this.ability = ability;\n\n    if (typeof Error.captureStackTrace === 'function') {\n      this.name = 'ForbiddenError';\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  setMessage(message: string): this {\n    this.message = message;\n    return this;\n  }\n\n  throwUnlessCan(...args: Parameters<T['can']>): void;\n  throwUnlessCan(action: string, subject?: Subject, field?: string): void {\n    const error = (this as any).unlessCan(action, subject, field);\n    if (error) throw error;\n  }\n\n  unlessCan(...args: Parameters<T['can']>): this | undefined;\n  unlessCan(action: string, subject?: Subject, field?: string): this | undefined {\n    const rule = this.ability.relevantRuleFor(action, subject, field);\n\n    if (rule && !rule.inverted) {\n      return;\n    }\n\n    this.action = action;\n    this.subject = subject;\n    this.subjectType = getSubjectTypeName(this.ability.detectSubjectType(subject));\n    this.field = field;\n\n    const reason = rule ? rule.reason : '';\n    // eslint-disable-next-line no-underscore-dangle\n    this.message = this.message || reason || (this.constructor as any)._defaultErrorMessage(this);\n    return this; // eslint-disable-line consistent-return\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}